       # Copyright 2013-present Barefoot Networks, Inc.
       #
       # Licensed under the Apache License, Version 2.0 (the "License");
       # you may not use this file except in compliance with the License.
       # You may obtain a copy of the License at
       #
       #   http://www.apache.org/licenses/LICENSE-2.0
       #
       # Unless required by applicable law or agreed to in writing, software
       # distributed under the License is distributed on an "AS IS" BASIS,
       # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       # See the License for the specific language governing permissions and
       # limitations under the License.
       #
       
    1: from mininet.net import Mininet
    1: from mininet.node import Switch, Host
    1: from mininet.log import setLogLevel, info, error, debug
    1: from mininet.moduledeps import pathCheck
    1: from sys import exit
    1: import os
    1: import tempfile
    1: import socket
    1: from time import sleep
       
    1: from netstat import check_listening_on_port
       
    1: SWITCH_START_TIMEOUT = 10 # seconds
       
    2: class P4Host(Host):
    1:     def config(self, **params):
    4:         r = super(Host, self).config(**params)
       
    4:         self.defaultIntf().rename("eth0")
       
   16:         for off in ["rx", "tx", "sg"]:
   12:             cmd = "/sbin/ethtool --offload eth0 %s off" % off
   12:             self.cmd(cmd)
       
               # disable IPv6
    4:         self.cmd("sysctl -w net.ipv6.conf.all.disable_ipv6=1")
    4:         self.cmd("sysctl -w net.ipv6.conf.default.disable_ipv6=1")
    4:         self.cmd("sysctl -w net.ipv6.conf.lo.disable_ipv6=1")
       
    4:         return r
       
    1:     def describe(self):
    4:         print "**********"
    4:         print self.name
    4:         print "default interface: %s\t%s\t%s" %(
    4:             self.defaultIntf().name,
    4:             self.defaultIntf().IP(),
    4:             self.defaultIntf().MAC()
               )
    4:         print "**********"
       
    2: class P4Switch(Switch):
    1:     """P4 virtual switch"""
    1:     device_id = 0
       
    1:     def __init__(self, name, sw_path = None, json_path = None,
    1:                  thrift_port = None,
    1:                  pcap_dump = False,
    1:                  log_console = False,
    1:                  log_file = None,
    1:                  verbose = False,
    1:                  device_id = None,
    1:                  enable_debugger = False,
                        **kwargs):
               Switch.__init__(self, name, **kwargs)
               assert(sw_path)
               assert(json_path)
               # make sure that the provided sw_path is valid
               pathCheck(sw_path)
               # make sure that the provided JSON file exists
               if not os.path.isfile(json_path):
                   error("Invalid JSON file.\n")
                   exit(1)
               self.sw_path = sw_path
               self.json_path = json_path
               self.verbose = verbose
               logfile = "/tmp/p4s.{}.log".format(self.name)
               self.output = open(logfile, 'w')
               self.thrift_port = thrift_port
               if check_listening_on_port(self.thrift_port):
                   error('%s cannot bind port %d because it is bound by another process\n' % (self.name, self.grpc_port))
                   exit(1)
               self.pcap_dump = pcap_dump
               self.enable_debugger = enable_debugger
               self.log_console = log_console
               if log_file is not None:
                   self.log_file = log_file
               else:
                   self.log_file = "/tmp/p4s.{}.log".format(self.name)
               if device_id is not None:
                   self.device_id = device_id
                   P4Switch.device_id = max(P4Switch.device_id, device_id)
               else:
                   self.device_id = P4Switch.device_id
                   P4Switch.device_id += 1
               self.nanomsg = "ipc:///tmp/bm-{}-log.ipc".format(self.device_id)
       
    1:     @classmethod
           def setup(cls):
    1:         pass
       
    1:     def check_switch_started(self, pid):
               """While the process is running (pid exists), we check if the Thrift
               server has been started. If the Thrift server is ready, we assume that
               the switch was started successfully. This is only reliable if the Thrift
               server is started at the end of the init process"""
               while True:
                   if not os.path.exists(os.path.join("/proc", str(pid))):
                       return False
                   if check_listening_on_port(self.thrift_port):
                       return True
                   sleep(0.5)
       
    1:     def start(self, controllers):
               "Start up a new P4 switch"
               info("Starting P4 switch {}.\n".format(self.name))
               args = [self.sw_path]
               for port, intf in self.intfs.items():
                   if not intf.IP():
                       args.extend(['-i', str(port) + "@" + intf.name])
               if self.pcap_dump:
                   args.append("--pcap %s" % self.pcap_dump)
               if self.thrift_port:
                   args.extend(['--thrift-port', str(self.thrift_port)])
               if self.nanomsg:
                   args.extend(['--nanolog', self.nanomsg])
               args.extend(['--device-id', str(self.device_id)])
               P4Switch.device_id += 1
               args.append(self.json_path)
               if self.enable_debugger:
                   args.append("--debugger")
               if self.log_console:
                   args.append("--log-console")
               info(' '.join(args) + "\n")
       
               pid = None
               with tempfile.NamedTemporaryFile() as f:
                   # self.cmd(' '.join(args) + ' > /dev/null 2>&1 &')
                   self.cmd(' '.join(args) + ' >' + self.log_file + ' 2>&1 & echo $! >> ' + f.name)
                   pid = int(f.read())
               debug("P4 switch {} PID is {}.\n".format(self.name, pid))
               if not self.check_switch_started(pid):
                   error("P4 switch {} did not start correctly.\n".format(self.name))
                   exit(1)
               info("P4 switch {} has been started.\n".format(self.name))
       
    1:     def stop(self):
               "Terminate P4 switch."
    4:         self.output.flush()
    4:         self.cmd('kill %' + self.sw_path)
    4:         self.cmd('wait')
    4:         self.deleteIntfs()
       
    1:     def attach(self, intf):
               "Connect a data port"
               assert(0)
       
    1:     def detach(self, intf):
               "Disconnect a data port"
               assert(0)
