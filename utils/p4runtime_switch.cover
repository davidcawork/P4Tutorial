       # Copyright 2017-present Barefoot Networks, Inc.
       # Copyright 2017-present Open Networking Foundation
       #
       # Licensed under the Apache License, Version 2.0 (the "License");
       # you may not use this file except in compliance with the License.
       # You may obtain a copy of the License at
       #
       #    http://www.apache.org/licenses/LICENSE-2.0
       #
       # Unless required by applicable law or agreed to in writing, software
       # distributed under the License is distributed on an "AS IS" BASIS,
       # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       # See the License for the specific language governing permissions and
       # limitations under the License.
       #
       
    1: import sys, os, tempfile, socket
    1: from time import sleep
       
    1: from mininet.node import Switch
    1: from mininet.moduledeps import pathCheck
    1: from mininet.log import info, error, debug
       
    1: from p4_mininet import P4Switch, SWITCH_START_TIMEOUT
    1: from netstat import check_listening_on_port
       
    2: class P4RuntimeSwitch(P4Switch):
    1:     "BMv2 switch with gRPC support"
    1:     next_grpc_port = 50051
    1:     next_thrift_port = 9090
       
    1:     def __init__(self, name, sw_path = None, json_path = None,
    1:                  grpc_port = None,
    1:                  thrift_port = None,
    1:                  pcap_dump = False,
    1:                  log_console = False,
    1:                  verbose = False,
    1:                  device_id = None,
    1:                  enable_debugger = False,
    1:                  log_file = None,
                        **kwargs):
    4:         Switch.__init__(self, name, **kwargs)
    4:         assert (sw_path)
    4:         self.sw_path = sw_path
               # make sure that the provided sw_path is valid
    4:         pathCheck(sw_path)
       
    4:         if json_path is not None:
                   # make sure that the provided JSON file exists
    4:             if not os.path.isfile(json_path):
                       error("Invalid JSON file: {}\n".format(json_path))
                       exit(1)
    4:             self.json_path = json_path
               else:
                   self.json_path = None
       
    4:         if grpc_port is not None:
                   self.grpc_port = grpc_port
               else:
    4:             self.grpc_port = P4RuntimeSwitch.next_grpc_port
    4:             P4RuntimeSwitch.next_grpc_port += 1
       
    4:         if thrift_port is not None:
                   self.thrift_port = thrift_port
               else:
    4:             self.thrift_port = P4RuntimeSwitch.next_thrift_port
    4:             P4RuntimeSwitch.next_thrift_port += 1
       
    4:         if check_listening_on_port(self.grpc_port):
                   error('%s cannot bind port %d because it is bound by another process\n' % (self.name, self.grpc_port))
                   exit(1)
       
    4:         self.verbose = verbose
    4:         logfile = "/tmp/p4s.{}.log".format(self.name)
    4:         self.output = open(logfile, 'w')
    4:         self.pcap_dump = pcap_dump
    4:         self.enable_debugger = enable_debugger
    4:         self.log_console = log_console
    4:         if log_file is not None:
    4:             self.log_file = log_file
               else:
                   self.log_file = "/tmp/p4s.{}.log".format(self.name)
    4:         if device_id is not None:
                   self.device_id = device_id
                   P4Switch.device_id = max(P4Switch.device_id, device_id)
               else:
    4:             self.device_id = P4Switch.device_id
    4:             P4Switch.device_id += 1
    4:         self.nanomsg = "ipc:///tmp/bm-{}-log.ipc".format(self.device_id)
       
       
    1:     def check_switch_started(self, pid):
    7:         for _ in range(SWITCH_START_TIMEOUT * 2):
    7:             if not os.path.exists(os.path.join("/proc", str(pid))):
                       return False
    7:             if check_listening_on_port(self.grpc_port):
    4:                 return True
    3:             sleep(0.5)
       
    1:     def start(self, controllers):
    4:         info("Starting P4 switch {}.\n".format(self.name))
    4:         args = [self.sw_path]
   20:         for port, intf in self.intfs.items():
   16:             if not intf.IP():
   12:                 args.extend(['-i', str(port) + "@" + intf.name])
    4:         if self.pcap_dump:
    4:             args.append("--pcap %s" % self.pcap_dump)
    4:         if self.nanomsg:
    4:             args.extend(['--nanolog', self.nanomsg])
    4:         args.extend(['--device-id', str(self.device_id)])
    4:         P4Switch.device_id += 1
    4:         if self.json_path:
    4:             args.append(self.json_path)
               else:
                   args.append("--no-p4")
    4:         if self.enable_debugger:
                   args.append("--debugger")
    4:         if self.log_console:
    4:             args.append("--log-console")
    4:         if self.thrift_port:
    4:             args.append('--thrift-port ' + str(self.thrift_port))
    4:         if self.grpc_port:
    4:             args.append("-- --grpc-server-addr 0.0.0.0:" + str(self.grpc_port))
    4:         cmd = ' '.join(args)
    4:         info(cmd + "\n")
       
       
    4:         pid = None
    4:         with tempfile.NamedTemporaryFile() as f:
    4:             self.cmd(cmd + ' >' + self.log_file + ' 2>&1 & echo $! >> ' + f.name)
    4:             pid = int(f.read())
    4:         debug("P4 switch {} PID is {}.\n".format(self.name, pid))
    4:         if not self.check_switch_started(pid):
                   error("P4 switch {} did not start correctly.\n".format(self.name))
                   exit(1)
    4:         info("P4 switch {} has been started.\n".format(self.name))
       
